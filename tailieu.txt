1. Generics
2. Utility Types
- Partial<T> â†’ biáº¿n táº¥t cáº£ cÃ¡c field trong T thÃ nh optional.
- Required<T> â†’ biáº¿n táº¥t cáº£ cÃ¡c field thÃ nh báº¯t buá»™c.
- Readonly<T> â†’ táº¥t cáº£ field chá»‰ Ä‘á»c (khÃ´ng cho sá»­a).
- Pick<T, K> â†’ chá»n má»™t sá»‘ field tá»« T.
- Omit<T, K> â†’ bá» má»™t sá»‘ field khá»i T.
ğŸŸ¢ TÃ³m gá»n
Partial â†’ khi update.
Required â†’ khi muá»‘n Ã©p pháº£i Ä‘á»§ data.
Readonly â†’ khi data khÃ´ng Ä‘Æ°á»£c sá»­a.
Pick â†’ khi chá»‰ cáº§n má»™t vÃ i field.
Omit â†’ khi muá»‘n bá» Ä‘i má»™t vÃ i field.

3. Utility Type má»›i: Record<Keys, Type>.
DÃ¹ng Ä‘á»ƒ táº¡o object vá»›i key cá»‘ Ä‘á»‹nh vÃ  value cÃ³ kiá»ƒu xÃ¡c Ä‘á»‹nh.
Thay vÃ¬ viáº¿t dÃ i dÃ²ng interface, Record giÃºp code gá»n hÆ¡n.

4. Utility Types
KhÃ¡i niá»‡m
DÃ¹ng Ä‘á»ƒ loáº¡i bá» null vÃ  undefined khá»i type.
Khi ta muá»‘n cháº¯c cháº¯n giÃ¡ trá»‹ luÃ´n tá»“n táº¡i (khÃ´ng null/undefined).
infer â€” Ä‘Ã¢y lÃ  pháº§n ráº¥t máº¡nh cá»§a TS, dÃ¹ng Ä‘á»ƒ suy diá»…n type tá»« má»™t cáº¥u trÃºc phá»©c táº¡p.

5. Distributive Conditional Types lÃ  gÃ¬?
Trong TS, náº¿u em viáº¿t conditional type trÃªn union, thÃ¬ TS sáº½ phÃ¢n phá»‘i Ä‘iá»u kiá»‡n cho tá»«ng pháº§n tá»­ cá»§a union.
type ToArray<T> = T extends any ? T[] : never;
type A = ToArray<string>;
type B = ToArray<string | number>;
Láº¥y cáº£ 2; ****
type Loai<T> = T extends string ? never : T;
Loáº¡i cÃ¡i mÃ  mÃ¬nh muá»‘n bá» -> á»Ÿ trÃªn lÃ  string ***

6. Mapped Types lÃ  gÃ¬?
NÃ³ cho phÃ©p em biáº¿n Ä‘á»•i type dá»±a trÃªn keys cá»§a type khÃ¡c.
CRUD repository generic, cÃ³ thá»ƒ tÃ¡i dÃ¹ng cho má»i model (Product, User, Order...).
interface CrudRepository<T extends { id: any }> {
  add(item: T): void;
  read(id: T["id"]): T | undefined;
  update(id: T["id"], item: NullablePartial<T>): T | undefined;
  delete(id: T["id"]): boolean;
  getAll(): T[];
}

class InMemoryRepository<T extends { id: any }> implements CrudRepository<T> {
  private items: T[] = [];
  add(item: T): void {
    this.items.push(item);
    console.log(`âœ… ÄÃ£ thÃªm item:`, item);
  }
  read(id: T["id"]): T | undefined {
    return this.items.find((i) => i.id === id);
  }
  update(id: T["id"], update: NullablePartial<T>): T | undefined {
    const item = this.items.find((i) => i.id === id);
    if (!item) return undefined;
    Object.assign(item, update);
    return item;
  }
  delete(id: T["id"]): boolean {
    const index = this.items.findIndex((i) => i.id === id);
    if (index === -1) return false;
    this.items.splice(index, 1);
    return true;
  }
  getAll(): T[] {
    return this.items;
  }
}