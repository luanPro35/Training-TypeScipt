I) 1. Null: được sử dụng khi mà chúng ta cố tính gắn giá trị "rỗng có chủ đích" - tức là biến hiện tại chưa có dữ liệu, nhưng chắc chắn sẽ có sau này
Vidu: let userName: string | null = null;
userName = "Luan"

2. undefined: Khi mà chưa được gán giá trị hoặc là không trả về giá trị gì

let result: number | undefined;

function findName(name: string): number | undefined {
    if(name === "Luan") return 101;
    return undefined;
}

result = findName("Hai");
console.log(result);

3. any: là chưa biết biến chính xác nên là chính ta dùng tạm như cửa thoát hiểm, hạn chế sử dụng trong ts vì dễ bị run time, mất an toàn
let value: any;
value: 123;
value: "Luan";
value: true;

value.toUpperCase() nó vẫn sẽ nhận định là đúng

4. unknown: khi chưa biết kiểu dữ liệu gì vào thì mình có thể dùng cái này đỡ, nó an toàn hơn any
let name: unknown = "Luan";
if(typeof name = "string"){
    console.log(name.toUpperCase());
}

II) Union Types: Union cho phép một biến có thể thuộc nhiều kiểu dữ liệu khác nhau.

III) Intersection Types: là gộp nhiều type thành 1, tức là bắt buộc có đủ tất cả thuộc tính type đó

IV) Generics (kiểu tổng quát) cho phép bạn viết code có thể tái sử dụng mà vẫn an toàn kiểu dữ liệu.
Tên	Nghĩa thường dùng	Ví dụ điển hình
T	Type (kiểu tổng quát chính)	                                 function identity<T>(x: T): T
U	Type thứ hai, thường dùng khi có 2 kiểu liên quan	         function merge<T, U>(a: T, b: U): T & U
K	Key (khi dùng với keyof, hoặc để đại diện key của object)	 function getValue<T, K extends keyof T>(obj: T, key: K)
V	Value (giá trị, thường đi kèm với K)	                     Record<K, V>
E	Element (phần tử trong mảng, tập hợp, list)	                 class Stack<E> { push(item: E) {} }

V) Utility Types:

1. Pick: sẽ chỉ lấy những cái dữ liệu mà mình cần 
Vd: type user: Pick<User, "id" | "name">

2. Omit: nó sẽ bỏ qua cái kiểu object mà mình nhập vào vidu:
User = {
    id, name, age
} nhưng chúng ta chỉ muốn sử dụng id và name thôi thì chúng ta loại age với lệnh là Omit<User, "age">

3. Record: dùng để phân quyền cho mỗi obj, vidu là admin, user
type Role = "admin" | "user" | "member";
type RolePermissions = Record<Role, string[]>;

4. Partial<T> — biến tất cả thuộc tính thành optional: cái này thì chúng ta gọi bao nhiêu cái cũng được, không cần bắt buộc là phải gọi hết
5. Required<T> — biến tất cả thuộc tính thành bắt buộc: TRONG TYPE MÌNH KHAI BÁO CÁI GÌ THÌ BẮT BUỘC PHẢI GHI hết
6. Readonly<T> — biến tất cả thuộc tính thành readonly: cái này là nó không cho mình gán cái mới
7. Readonly<T> — biến tất cả thuộc tính thành readonly: dùng khi muốn bảo vệ object khỏi thay đổi, ví dụ config, constants.